<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Complete Guide to Creating OTClient Modules</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; line-height: 1.6; background-color: #f4f4f4; color: #222; }
    h1, h2, h3 { color: #005072; }
    code, pre { background: #eee; padding: 2px 4px; border-radius: 4px; }
    pre { padding: 1em; overflow-x: auto; border-left: 4px solid #005072; }
    .section { margin-bottom: 3em; }
  </style>
</head>
<body>
  <h1>Complete Guide to Creating OTClient Modules</h1>

  <div class="section">
    <h2>What Are OTClient Modules?</h2>
    <p>Modules in OTClient (OTC) are self-contained folders containing Lua logic and UI definition files (.lua and .otui) that extend the game's client functionality. Examples include hotkey bars, health trackers, battle lists, and custom UIs.</p>
  </div>

  <div class="section">
    <h2>Folder Structure</h2>
    <pre><code>modules/
  your_module/
    your_module.lua
    your_module.otui
    images/
    styles/
    other_scripts.lua
    your_module.otmod
</code></pre>
  </div>

<div class="section">
  <h2>OTMod File (.otmod)</h2>
  <p>Every module must include a <code>.otmod</code> file which defines its metadata and how it integrates with the client. Below is an example with detailed comments:</p>
  <pre><code>Module
  name: "Your Module"                -- Display name of the module
  description: "Does something cool." -- Description shown in module manager
  author: "Your Name"                -- Attribution field
  sandboxed: true                    -- Restricts global access for safety
  dependencies: [ ]                  -- List of other modules this one depends on
  scripts: ["your_module.lua"]       -- Lua scripts to load (OTCv8 can skip .lua)
  @onLoad: init()                    -- Lua function to call when module loads
  @onUnload: terminate()             -- Lua function to call on unload
</code></pre>
  <p>Note: Modern forks like <code>OTCv8</code> allow skipping <code>.lua</code> in script names, but it's recommended to always include it for compatibility.</p>
</div>


<div class="section">
  <h2>Lua Logic File (your_module.lua)</h2>
  <p>This script contains the core logic that runs when your module is loaded or unloaded. The functions <code>init()</code> and <code>terminate()</code> are defined in your .otmod file and will be executed by the OTClient framework.</p>
  <pre><code>function init()
  -- Load the UI layout defined in your_module.otui
  g_ui.loadUI("your_module.otui")

  -- Create a MainWindow widget and attach it to the root interface
  myWindow = g_ui.createWidget("MainWindow", rootWidget)
end

function terminate()
  -- Always clean up your widgets when unloading the module
  -- This ensures there are no memory leaks or duplicated windows
  if myWindow then
    myWindow:destroy()  -- Destroy removes the widget from memory
    myWindow = nil      -- Unset the reference to help garbage collection
  end
end</code></pre>
  <p><strong>Explanation:</strong></p>
  <ul>
    <li><code>init()</code> is called automatically when the module is loaded (as defined in <code>@onLoad</code>).</li>
    <li><code>g_ui.loadUI()</code> loads the .otui layout into memory.</li>
    <li><code>g_ui.createWidget()</code> instantiates the root widget.</li>
    <li><code>terminate()</code> is executed when unloading — this is where you destroy custom UI to avoid bugs or memory leaks.</li>
    <li><code>:destroy()</code> ensures the widget is removed from both the screen and memory — always pair this with <code>myWidget = nil</code>.</li>
  </ul>
</div>



<div class="section">
  <h2>OTUI Files and Attributes</h2>
  <p>OTUI files define the visual layout and styling of widgets using a custom markup format. Below is an example layout with inline comments.</p>
  <pre><code>MainWindow                             -- Main container window with title bar and close button
  id: myWindow                          -- ID to reference this widget from Lua
  size: 300 200                         -- Width and height
  text: "My Example"                   -- Window title
  @onClick: function()                 -- Click handler using inline Lua
    g_logger.info("Clicked window")
  end

  Button                               -- A child widget (indented under MainWindow)
    id: closeButton                    -- Button's unique ID
    text: "Close"                      -- Label on the button
    anchors.bottom: parent.bottom     -- Anchor this button to bottom of parent
    @onClick: function()               -- On click, close the parent window
      myWindow:destroy()
    end
</code></pre>

  <h3>Attribute Reference</h3>
  <p>These are the most commonly used attributes across OTUI widget types.</p>

  <h4>Common Attributes</h4>
  <ul>
    <li><strong>id</strong>: Unique name to reference the widget from Lua.</li>
    <li><strong>size</strong>: Format: <code>width height</code>, e.g. <code>size: 100 20</code>.</li>
    <li><strong>position</strong>: Manual placement within parent, e.g. <code>position: 20 30</code>.</li>
    <li><strong>anchors</strong>: Anchor this widget relative to its parent or siblings. Can use <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>, or <code>fill</code>.</li>
    <li><strong>margin</strong>: Outside spacing. Can be single or multiple values: <code>margin: 10</code> or <code>margin: 5 10 5 10</code>.</li>
    <li><strong>padding</strong>: Inner spacing between the border and content.</li>
    <li><strong>visible</strong>: Set to <code>false</code> to hide widget by default.</li>
    <li><strong>enabled</strong>: Set to <code>false</code> to disable interaction (e.g. greys out buttons).</li>
    <li><strong>opacity</strong>: Value from 0 (transparent) to 1 (opaque).</li>
  </ul>

  <h4>Text Attributes</h4>
  <ul>
    <li><strong>text</strong>: The label or string displayed inside the widget.</li>
    <li><strong>text-align</strong>: <code>left</code>, <code>center</code>, <code>right</code>.</li>
    <li><strong>text-offset</strong>: Shifts text inside widget, e.g. <code>text-offset: 2 2</code>.</li>
    <li><strong>text-auto-resize</strong>: Auto-expand the widget to fit text.</li>
    <li><strong>font</strong>: Font preset, e.g. <code>verdana-11px-rounded</code>.</li>
    <li><strong>color</strong>: Color of the text. Can be named or hex: <code>#FFFFFF</code>.</li>
  </ul>

  <h4>Image Attributes</h4>
  <ul>
    <li><strong>image-source</strong>: Path to image file (e.g. <code>/images/myicon.png</code>).</li>
    <li><strong>image-rect</strong>: Region of the image to display: <code>x y width height</code>.</li>
    <li><strong>image-smooth</strong>: Smooth image scaling (true/false).</li>
    <li><strong>icon</strong>: Named image from a sprite atlas.</li>
  </ul>

  <h4>Layout & Container Attributes</h4>
  <ul>
    <li><strong>layout</strong>: Controls layout of child widgets. Use <code>verticalBox</code>, <code>horizontalBox</code>, or <code>grid</code>.</li>
    <li><strong>fit-children</strong>: Automatically resize parent to match content.</li>
    <li><strong>spacing</strong>: Sets spacing between children in layout containers.</li>
    <li><strong>auto-resize</strong>: Makes widget resize on content changes.</li>
  </ul>

  <h4>Style & Border</h4>
  <ul>
    <li><strong>background-color</strong>: Widget background color.</li>
    <li><strong>border</strong>: Format: <code>width color</code>, e.g. <code>1 #FF0000</code>.</li>
    <li><strong>border-width</strong>: Set border per side: <code>border-width: 1 2 1 2</code>.</li>
    <li><strong>border-color</strong>: Set color per side: <code>border-color: #000 #222 #000 #222</code>.</li>
  </ul>

  <h4>Event Handlers</h4>
  <ul>
    <li><strong>@onClick</strong>: Executes when widget is clicked.</li>
    <li><strong>@onHoverChange</strong>: Triggers when mouse hovers in/out.</li>
    <li><strong>@onTextChange</strong>: Triggers when text value changes.</li>
    <li><strong>@onEnter</strong>: Mouse enters widget.</li>
    <li><strong>@onLeave</strong>: Mouse leaves widget.</li>
  </ul>
</div>
<div class="section">
    <h2>Advanced Tips & Tricks</h2>
    <p><strong>Note on .lua Extensions in .otmod Files:</strong> In classic OTClient, script filenames in the <code>scripts:</code> array <em>must</em> include the <code>.lua</code> extension. However, in modern forks like <code>OTCv8</code>, the client automatically appends <code>.lua</code> if it's missing. Example:</p>
    <pre><code>scripts: ["example.lua"]     -- always works
scripts: ["example"]         -- works only in OTCv8 and similar forks</code></pre>
    <p>For maximum compatibility across clients, always include the full filename with the <code>.lua</code> extension.</p>
    <ul>
      <li><strong>Use <code>fit-children: true</code></strong> on layout panels to allow auto-sizing for nested widgets.</li>
      <li>Use <code>anchors.fill: parent</code> to make widgets automatically stretch and fit their container.</li>
      <li>Combine <code>margin</code> and <code>padding</code> for clean spacing without needing nested panels.</li>
      <li>Use <code>focusable: false</code> for labels or non-interactive elements to avoid them intercepting keyboard focus.</li>
      <li>Manage widgets via their <code>id</code> in Lua: <code>myWidget = rootWidget:getChildById("myId")</code></li>
      <li>Wrap groups of widgets in a Panel to allow toggling their visibility with one call.</li>
      <li><strong>Use g_keyboard.bindKeyPress</strong> in Lua to create custom hotkeys inside your modules.</li>
      <li>Leverage <code>UICreature</code> or <code>UIItem</code> for creature/item previews and inventory widgets.</li>
    </ul>
  </div>

<div class="section">
  <h2>Using Extended Opcodes</h2>
  <p>Extended opcodes allow OTClient and the server to exchange custom messages, beyond the default protocol. They're extremely useful for adding features like UI-server communication, achievements, or custom task systems.</p>

  <h3>Server-Side (Lua - TFS)</h3>
  <pre><code>function onExtendedOpcode(player, opcode, buffer)
  -- Called automatically when client sends an extended opcode
  if opcode == 42 then
    print("Received from client:", buffer)

    -- Respond back to the client using the same opcode
    player:sendExtendedOpcode(42, "response from server")
  end
  return true
end
</code></pre>
  <p><strong>Explanation:</strong> This function should be registered in TFS's <code>creaturescripts.xml</code>. You can define multiple opcodes and use <code>buffer</code> as the custom message content.</p>

  <h3>Client-Side (Lua - OTClient)</h3>
  <pre><code>function init()
  -- Register a client-side handler for opcode 42
  ProtocolGame.registerExtendedOpcode(42, onOpcode42)
end

function onOpcode42(protocol, opcode, buffer)
  -- This is called when server sends an extended opcode 42
  g_logger.info("Received from server: " .. buffer)
end

function sendMyOpcode()
  -- Send data to the server only if connected
  if g_game.isOnline() then
    g_game.sendExtendedOpcode(42, "hello from client")
  end
end
</code></pre>

  <p><strong>Key Points:</strong></p>
  <ul>
    <li><code>ProtocolGame.registerExtendedOpcode</code>: Registers a Lua function to handle server responses.</li>
    <li><code>g_game.sendExtendedOpcode(opcode, buffer)</code>: Sends a custom message to the server.</li>
    <li><code>buffer</code> can be plain text, JSON, CSV, or any string — it's your protocol.</li>
  </ul>

  <p>This is useful for implementing:</p>
  <ul>
    <li>Sending form input (like task progression or preferences) to the server</li>
    <li>Getting structured data back from the server (e.g. JSON tables)</li>
    <li>Triggering backend logic (achievement unlocked, event joined, etc.)</li>
  </ul>

  <p><strong>Tips:</strong></p>
  <ul>
    <li>Always verify <code>g_game.isOnline()</code> before sending opcodes</li>
    <li>Use a unique opcode ID (between 1–255) to avoid conflicts</li>
    <li>Consider using JSON.stringify / decode for structured messages</li>
  </ul>
</div>
</html>
